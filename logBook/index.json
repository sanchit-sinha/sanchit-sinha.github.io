[{"content":"The Theory of C++ Basics of C++ Variables: In programming, a variable is a container (storage area) to hold data. They can-not be keywords.\nLiterals: Literals are data used for representing fixed values like integer, character, strings and floating numbers.\nConstants: Their values cannot change. Certain variables defined using consts or #define can also act as constants.\nBasic Input/Output cout  The cout object in C++ is an object of class ostream. It is defined in the iostreamheader file. It is used to display the output to the standard output device i.e. monitor. It is associated with the standard C output stream stdout. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(\u0026lt;\u0026lt;). cout sends formatted output to standard output devices, such as the screen We first include the iostream header file that allows us to display output. The cout object is defined inside the std namespace. To use the std namespace, we used the using namespace std; statement.  cin  In C++, cin takes formatted input from standard input devices such as the keyboard. We use the cin object along with the \u0026raquo; operator for taking input  Functions Function Prototype  declaration of a function that specifies the function’s name and type signature (input/output of the function without the function body)  Function overloading  Functions having same name but different input parameters/arguments In C++, many built-in functions like sqrt are overloaded.  Default Parameters  Default arguments can also be provided to functions which will get over-written once the function is called with any proper argument. Once, we provide a default argument to function, then all the subsequent parameters must also have a default value.  Storage class Local variable/Automatic variables  Local Variables defined within a function that is, their scope is limited to a function. They end as soon as the function exits.  Global Variables  These variables are defined outside of all the functions Their scope is the entire program that is they end when the program ends  Static Local Variable  It exists and can be used only within certain functions where defined. Unlike local variables it maintains its value throughout the program,  Register variables  It is no longer used after C++11 These are similar to local variables but are a bit faster, that is they store variables in the processor\u0026rsquo;s register(small set of data holding capacity in CPU) instead of processor’s memory.  Thread local storage  Variables are allocated such that there is one instant of variable per thread  Return by reference  We return the return type of functions by reference These functions cannot return local variables or constants, they should return global variables.  Structures  It is a collection of variables of different data types. When a structure is created no memory is allocated. Memory is allocated only when the variable is defined. Structure can be thought of only as a blueprint. The members of the structure are accessed using dot[.]. This [.] is used to access the child object directly.  Using Pointers in Structures  If we define an address of a structure using pointers, we will still not be able to access the elements of the structure as we have not allocated any memory to them. struct_name * var_name = new struct_name(). This is similar to malloc, that is it allocates memory to the pointer created.  C++ Enumerations  User defined data-type which assigns constants to global variables. By default the value is given in the order [0,1,2…] An enum variable takes only value denied in the enumeration.  Class Class  Contains all the related data and functions at one place It is a blueprint of the object. For example Sketch of a house is a class and the house itself is an object It is created using the keyword class and has private and public keywords.  Public  Members defined within the public can be accessed from anywhere within the program.  Private  Members defined within the private can be accessed only within the class.  Constructors  Has the same name as that of the class, doesn’t have any return type and is public.  Default Constructor  Constructor having no parameters is the default constructor. It is called as soon as the variable is defined.  Parameterized Constructor  They take certain arguments within them. These arguments are used to initialise the variables defined within the class.  Operator Overloading   This allows us to change the way operators work. However this doesn’t work with fundamental data types like int, float and char . Syntax:  returnType operator symbol (arguments) { ... .. ... }  Here return type is the value to be returned while operator is a keyword. Symbol takes values like +,-,*,/ and arguments take the operands. Unary operators like ++ or -- can be a void with no argument type. For postfix (++value) function we have the following syntax.. void operator ++(int)  Structure vs Class A structure is a value type so it is stored on the stack, but a class is a reference type and is stored on the heap. A structure doesn\u0026rsquo;t support inheritance, and polymorphism, but a class supports both. By default, all the struct members are public but class members are by default private in nature.\nC++ Pointers  Pointer stores the address of a variable. int* ptr, p ..here ptr is of the type int* while p is of the type int * is used to dereference pointers and to access the value at that address.  C++ Memory Management  Keywords new and delete are used to allocate and deallocate the memory dynamically new operator  This operator allocates memory to the variable. Syntax: ptr_name = new data type   Delete operator  It deallocates the memory, that is, it returns back to the operating system. Syntax: delete ptr_name    C++ Inheritance  Allows us to create new class from the base class The derived class has access to all the elements of the base class. It has access to all the features of the base class and can add its own feature as well We can use keyword public, private and protected while inheriting the class  Syntax: class Dog : public Animal {...}; is-a relationship  Inheritance can be used only if is-a relationship is present  C++ protected members  Like private members, protected members are inaccessible outside of the class. However, they are accessible by derived and friend classes It is used if we want data to not be accessed outside the class but still be accessed by derived class Moreover, private members from the base class cannot be directly used in the derived classes.  Access Modes Public  The members of the base class are inherited by derived class just as the members are  Private  All the members of the base class becomes private members in derived class  Protected  The public members of the base class becomes the protected members of the derived class   Note that private members of the base class remain as private members of the private class in all the access modes.\n  Member function overriding in inheritance  It may happen that the base class and the inherited class have the member functions with the same name. In that case,if a variable is called then the access mode of the derived class is invoked first.    Function Overloading   If the same function is defined in both- base as well as the derived class and we call that function, then the function of the derived class is executed. To access the overridden function of the base class we use the scope resolution operator. For instance Base:: is used to access members of the base class. A pointer of the base type can also be used for that purpose.  Types of Inheritance  Multilevel Inheritance  In a program we can also derive a class from the derived class  Multiple Inheritance  In a program, a class can be derived from more than one parent/base class If a function is overridden in both the parent classes, then our program throws compilation error as it doesn’t know which function to execute. However this can be resolved using scope resolution.  Hierarchical Inheritance  If more than one class is inherited from a base class, it is called hierarchical inheritance.  Friend Function and classes Friend Function  These functions can access the public as well as the private data members of the class. It is defined with the keyword friend.. Syntax: friend returnType functionName(arguments);  Friend Class  When a class is declared as a friend class, all the member functions of the friend class become friend functions. All the members of the base class are accessible under this friend class.   Syntax: friend class ClassB;  However, we cannot access members of the friend class from the base class as friendship in C++ is one way only.  Virtual Functions  A virtual function is used in the base class to ensure that function is overridden in the derived class. Thus if we try to access any member function of the base class using base pointer, then also we will get the overridden function written in the derived class. Syntax:(written in base class)  virtual void print() { // code  }  C++ override identifier (which is written with the derived class member functions) is used to indicate which function will override the base class function. This ensures that the compiler pops out an error if the derived class function does not meet the function requirements of the base class function. Note that we can still access the base function using scope resolution.  C++ Polymorphism  This means that a given variable or function behaves differently in different scenarios.  Function Overloading  We can use same functions with same name but different arguments(different argument type, return type, argument number) It is a compiler-time polymorphism because the compiler knows which function to execute even before the program is compiled.  Operator Overloading  We can operate operator as long as we are operating on user defined structures and objects It is a compiler-time polymorphism because the compiler knows which function to execute even before the program is compiled.  Function Overriding  A function of the base class can be overridden by the function in the derived class It is a run-time polymorphism as the function call is not resolved by the compiler but is resolved during the runtime  Virtual Functions  They ensure that the function in the base class is overridden even if we access the function by base pointer. It is a run-time polymorphism as the function call is not resolved by the compiler but is resolved during the runtime  C++ Templates  We can create a single function using multiple data-types  Function Templates  Declaration:  template class T T someFunction(T arg) { ... .. ... }  Keyword typename can be used instead of class  Class Templates  Creating class object as : classname \u0026lt; dataype\u0026gt; objectname Declaration : template\u0026lt;classT\u0026gt;  class className { ... .. ... public: T var; T someOperation(T arg); ... .. … }; ","permalink":"https://sanchit-sinha.github.io/logBook/posts/basics-of-c++/","summary":"Short Notes regardging C++ and OOPs","title":"Basics of C++"}]